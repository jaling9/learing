<!DOCTYPE html>
  <!DOCTYPE html>
  <html>
  <head>
  	<meta charset="utf-8">
	<title>三栏布局</title>
	<style>
		* {
			box-sizing: border-box;
		}
            html,body {
	            margin:0 auto; 
	            height:auto;
            }

			.main { 
				float: left;
				height:auto ;
	            width:calc(100% - 400px);
	            background:blue;
			}

		    .left , .right {
		    	height:auto ;
		    	width: 200px;
				background: red;
		    }

			.left {
				float: left;
			}

			.right {
				float: right;
			}	
			



	</style>
  </head>
  <body>
		<div class="left">当这样的图像用于边界图像时，浏览器将图像分割为8个部分，如下一个图像所示： 这些角的图像会被插入到你的边界的角落里，而顶部、右边、底部和左边的部分将被用来填充你的边界的相应边(通过拉伸或重复)。我们需要告诉浏览器让这些片的大小正确——例如，这个图像是160px，还有一个4 x 4的网格，所以每个片都需要40px。 首先，我们需要一个盒子来应用边界。这需要指定一个边界，否则边界图像将没有显示的空间。我们还将使用background-clip，使任何背景色只填充内容和内边距的区域，并且不扩展到边界(您可能不希望这样做，但是在这样的情况下是有用的)。 border: 30px solid black; background-clip: padding-box; 注意：您应该始终包括border定义，以及任何使用border-image——如果浏览器不支持该特性，则该操作可以作为一个回退，以防止边界图像无法显示。 接下来,我们将使用 border-image-source指定要使用的源图像作为边界图像。 它的工作原理和background-image一样，能够接受一个url()函数或一个渐变作为一个值。 border-image-source: url(border-image.png); 现在，我们将使用border-image-slice来设置所需大小的切片，如上所述： border-image-slice: 40; 如果所有的片都是相同的大小，那么这个属性可以取一个值，如果需要不同的大小，则可以使用多个值，以相同的方式使用padding和margin： 两个值:上和下，左和右。 三个值:上、左和右、下。 四个值:上、右、下、左。 如果图像是光栅图形（像 .png 或 .jpg），就用像素来解释这个数字。如果图像是矢量图形（比如，.svg），那么这个数字将被解释为图形中的坐标。也可以使用百分比（使用单位 %）。查看 border-image-slice页面，获得更多的选项和详细信息。 注意：默认情况下，第9部分(即中间部分)被完全省略，而元素内容出现在剩下的空白中。如果您想要的是边界图像的中心，您可以通过在您的border-image-source的末尾包含关键字fill，在这种情况下，它将扩展到适合背景区域。 最后，我们将使用border-image-repeat t来指定我们希望图像如何填充边界。选项是： stretch：默认;侧面的图像被拉伸来填满边界。这通常看起来很糟糕和像素化，所以不推荐。 repeat：边图像被重复，直到边界被填满。根据具体情况，这可能看起来不错，但您可能会看到一些难看的图像片段。 round： 边的图像被重复，直到边界被填满，它们都被稍微拉伸，这样就不会出现碎片。 space：边图像被重复，直到边界被填满，每个拷贝之间添加了少量的间隔，这样就不会出现任何片段。这个值只在Safari(9+)和Internet Explorer(11+)中得到支持。 我们决定使用round的值，因为它看起来是最有用和最灵活的： border-image-repeat: round;</div>
		
		<div class="right">当这样的图像用于边界图像时，浏览器将图像分割为8个部分，如下一个图像所示： 这些角的图像会被插入到你的边界的角落里，而顶部、右边、底部和左边的部分将被用来填充你的边界的相应边(通过拉伸或重复)。我们需要告诉浏览器让这些片的大小正确——例如，这个图像是160px，还有一个4 x 4的网格，所以每个片都需要40px。 首先，我们需要一个盒子来应用边界。这需要指定一个边界，否则边界图像将没有显示的空间。我们还将使用background-clip，使任何背景色只填充内容和内边距的区域，并且不扩展到边界(您可能不希望这样做，但是在这样的情况下是有用的)。 border: 30px solid black; background-clip: padding-box; 注意：您应该始终包括border定义，以及任何使用border-image——如果浏览器不支持该特性，则该操作可以作为一个回退，以防止边界图像无法显示。 接下来,我们将使用 border-image-source指定要使用的源图像作为边界图像。 它的工作原理和background-image一样，能够接受一个url()函数或一个渐变作为一个值。 border-image-source: url(border-image.png); 现在，我们将使用border-image-slice来设置所需大小的切片，如上所述： border-image-slice: 40; 如果所有的片都是相同的大小，那么这个属性可以取一个值，如果需要不同的大小，则可以使用多个值，以相同的方式使用padding和margin： 两个值:上和下，左和右。 三个值:上、左和右、下。 四个值:上、右、下、左。 如果图像是光栅图形（像 .png 或 .jpg），就用像素来解释这个数字。如果图像是矢量图形（比如，.svg），那么这个数字将被解释为图形中的坐标。也可以使用百分比（使用单位 %）。查看 border-image-slice页面，获得更多的选项和详细信息。 注意：默认情况下，第9部分(即中间部分)被完全省略，而元素内容出现在剩下的空白中。如果您想要的是边界图像的中心，您可以通过在您的border-image-source的末尾包含关键字fill，在这种情况下，它将扩展到适合背景区域。 最后，我们将使用border-image-repeat t来指定我们希望图像如何填充边界。选项是： stretch：默认;侧面的图像被拉伸来填满边界。这通常看起来很糟糕和像素化，所以不推荐。 repeat：边图像被重复，直到边界被填满。根据具体情况，这可能看起来不错，但您可能会看到一些难看的图像片段。 round： 边的图像被重复，直到边界被填满，它们都被稍微拉伸，这样就不会出现碎片。 space：边图像被重复，直到边界被填满，每个拷贝之间添加了少量的间隔，这样就不会出现任何片段。这个值只在Safari(9+)和Internet Explorer(11+)中得到支持。 我们决定使用round的值，因为它看起来是最有用和最灵活的： border-image-repeat: round;</div>
		<div class="main">当这样的图像用于边界图像时，浏览器将图像分割为8个部分，如下一个图像所示： 这些角的图像会被插入到你的边界的角落里，而顶部、右边、底部和左边的部分将被用来填充你的边界的相应边(通过拉伸或重复)。我们需要告诉浏览器让这些片的大小正确——例如，这个图像是160px，还有一个4 x 4的网格，所以每个片都需要40px。 首先，我们需要一个盒子来应用边界。这需要指定一个边界，否则边界图像将没有显示的空间。我们还将使用background-clip，使任何背景色只填充内容和内边距的区域，并且不扩展到边界(您可能不希望这样做，但是在这样的情况下是有用的)。 border: 30px solid black; background-clip: padding-box; 注意：您应该始终包括border定义，以及任何使用border-image——如果浏览器不支持该特性，则该操作可以作为一个回退，以防止边界图像无法显示。 接下来,我们将使用 border-image-source指定要使用的源图像作为边界图像。 它的工作原理和background-image一样，能够接受一个url()函数或一个渐变作为一个值。 border-image-source: url(border-image.png); 现在，我们将使用border-image-slice来设置所需大小的切片，如上所述： border-image-slice: 40; 如果所有的片都是相同的大小，那么这个属性可以取一个值，如果需要不同的大小，则可以使用多个值，以相同的方式使用padding和margin： 两个值:上和下，左和右。 三个值:上、左和右、下。 四个值:上、右、下、左。 如果图像是光栅图形（像 .png 或 .jpg），就用像素来解释这个数字。如果图像是矢量图形（比如，.svg），那么这个数字将被解释为图形中的坐标。也可以使用百分比（使用单位 %）。查看 border-image-slice页面，获得更多的选项和详细信息。 注意：默认情况下，第9部分(即中间部分)被完全省略，而元素内容出现在剩下的空白中。如果您想要的是边界图像的中心，您可以通过在您的border-image-source的末尾包含关键字fill，在这种情况下，它将扩展到适合背景区域。 最后，我们将使用border-image-repeat t来指定我们希望图像如何填充边界。选项是： stretch：默认;侧面的图像被拉伸来填满边界。这通常看起来很糟糕和像素化，所以不推荐。 repeat：边图像被重复，直到边界被填满。根据具体情况，这可能看起来不错，但您可能会看到一些难看的图像片段。 round： 边的图像被重复，直到边界被填满，它们都被稍微拉伸，这样就不会出现碎片。 space：边图像被重复，直到边界被填满，每个拷贝之间添加了少量的间隔，这样就不会出现任何片段。这个值只在Safari(9+)和Internet Explorer(11+)中得到支持。 我们决定使用round的值，因为它看起来是最有用和最灵活的： border-image-repeat: round;</div>
  </body>
  </html>
	

	

